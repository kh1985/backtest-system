# 2026-02-05 セッションログ

## 究極目標の再確認

ユーザーが目指すバックテストシステムの最終形態:
- **データ**: BTCUSDT等の複数銘柄
- **レジーム別分析**: 上昇トレンド / レンジ / 下落トレンド
- **自動発見**: 各レジームで「どのインジケーター組み合わせにエッジがあるか」を自動検証
- **自律改善**: 人間が仮説を立てるのではなく、AIが自律的に仮説生成→検証→改善ループを回す

現状の課題: 人間（ユーザー）が「テンプレートが悪いかも」「パラメータ変えよう」と考えて手動で改善している

---

## 自律的戦略発見システムのリサーチ結果

### 4つの主要アプローチ

#### 1. LLMマルチエージェント（TradingAgents, CrewAI, LangGraph）

**概要**: ChatGPTのようなAIを複数人のチームにして役割分担で仕事させる

**仕組み**:
- AI社員A（アナリスト）: チャート分析して戦略提案
- AI社員B（開発者）: 戦略コード作成
- AI社員C（テスター）: バックテスト実行
- AI社員D（リスク管理）: ドローダウン等をチェック
→ これらが自動で議論・改善ループを回す

**ツール**:
- [TradingAgents](https://github.com/TauricResearch/TradingAgents): LangGraph + GPT-4o/o1ベース。トレード専用
- [CrewAI](https://github.com/crewAIInc/crewAI): 汎用マルチエージェント。YAML設定で高速プロトタイプ
- LangGraph: 状態管理付きワークフロー。TradingAgentsの基盤

**難易度**: 高（設計が複雑）

---

#### 2. 強化学習（Agent Lightning, FinRL, AlphaGen）

**概要**: ゲームを何万回もプレイして上手くなるAIと同じ仕組み

**仕組み**:
```
1回目: RSI=30でロング → 負けた → 「この設定ダメ」と学習
2回目: RSI=25に変更 → 勝った → 「こっちがいい」と学習
...
10000回目: 最適パラメータを自動発見
```

**ツール**:
- [Agent Lightning](https://whatworksintrading.substack.com/p/training-ai-trading-agents-with-agent) (Microsoft): 既存システムに後付け可能。モデル再訓練不要。44%シャープ向上事例
- [FinRL](https://github.com/AI4Finance-Foundation/FinRL): DRL専用フレームワーク。PPO/SAC/A2C等提供
- [AlphaGen](https://github.com/RL-MLDM/alphagen): RLでアルファ式を自動発見（KDD 2023論文）

**難易度**: 低〜中（特にAgent Lightningは後付け容易）

---

#### 3. 遺伝的アルゴリズム（GeneTrader, Vectorial GP）

**概要**: 生き残りゲーム。強い戦略だけが子孫を残して進化する

**仕組み**:
```
第1世代: 100種類の戦略をランダム生成 → バックテスト → 上位20個生き残り
第2世代: 生き残りを「交配」（戦略Aの条件 + 戦略BのSL設定 = 子供）
         + 突然変異 → また100個に → 上位20個生き残り
...
第100世代: めっちゃ強い戦略が残っている
```

**グリッドサーチとの違い**: 全パターン試すのではなく、良さそうな方向だけ効率的に探索

**ツール**:
- [GeneTrader](https://github.com/imsatoshi/GeneTrader): GAでパラメータ最適化
- [Vectorial GP](https://arxiv.org/html/2504.05418v1): 戦略式の構造自体を進化

**難易度**: 中

---

#### 4. Alpha Discovery（AlphaGen, Alpha2, Alpha-GFN）

**概要**: インジケーターの組み合わせ式を、AIが自動で発明する

**仕組み**:
```
AIが自動で試す:
- RSI < 30 → ダメ
- RSI < 25 AND SMA20 > SMA50 → まあまあ
- (RSI < 30 OR Stoch < 20) AND Volume > 平均*1.5 → いい感じ
→ 人間が思いつかない組み合わせを発見
```

**DSL（ドメイン固有言語）**: インジケーター条件を数式として表現
```
エントリー = (RSI_14 < 30) AND (Close < BB_lower_20) AND (Volume > SMA_volume_20 * 1.5)
```
この数式自体をAIが自動生成する

**ツール**:
- [AlphaGen](https://github.com/RL-MLDM/alphagen): RLでアルファ因子生成（KDD 2023）
- [Alpha2](https://arxiv.org/html/2406.16505v2): 論理式アルファ発見
- [Alpha-GFN](https://github.com/nshen7/alpha-gfn): GFlowNetベース

**難易度**: 中

---

### 推奨実装順序

| 優先度 | アプローチ | 理由 |
|--------|-----------|------|
| 1 | **強化学習（Agent Lightning）** | 今のPrismに後付けしやすい |
| 2 | 遺伝的アルゴリズム | グリッドサーチの上位互換 |
| 3 | Alpha Discovery | インジケーター組み合わせ自動発見 |
| 4 | マルチエージェント | 最終形態だが設計複雑 |

---

---

## 検証スピード問題と現実的な判断

### 現状の問題

| 項目 | 値 |
|------|-----|
| PC | MacBook Air M1/M2 |
| コア | 8 |
| メモリ | 16GB |
| 3銘柄の最適化 | 約4時間 |
| 30銘柄換算 | 約40時間 |

→ バックテストが遅いため「自動化しないと回らない」という発想になっていた

### 検討した選択肢

| 選択肢 | コスト | 判断 |
|--------|--------|------|
| クラウド（AWS/GCP） | 月5000円〜 | 見送り |
| デスクトップPC購入 | 10-20万円 | 見送り |
| 手持ちのWindows PC | 無料 | スペック不足（i5-8265U/8GB、MacBook Airより遅い） |
| 探索範囲を絞る | 無料 | **採用** |

### ユーザーの判断

「すぐ金を使うのは悪い癖」→ 今あるもので工夫する

---

## 現実的な進め方（採用）

### 探索範囲を絞る

| 絞り方 | 効果 |
|--------|------|
| ロングだけ | 半分 |
| 1レジームだけ | 3分の1 |
| 1テンプレートだけ | 6分の1 |

例：「レンジ × ショート × MACD」だけに絞れば、数十分の1の時間で回せる

### 役割分担

```
ユーザー: バックテスト回す → 結果を見せる
Claude:   結果を分析 → 次の仮説を提案
→ 繰り返し
```

フルオートではないが、**仮説生成はClaudeがやる**。
マルチエージェントシステムを組まなくても、この形で「自動発見」に近いことはできる。

---

---

## 遺伝的アルゴリズム（GA）実装決定

### 認識合わせ完了

ユーザーとの認識合わせで以下が確定：

| 項目 | 状態 |
|------|------|
| レジーム判定方式（MA Cross/ADX/HHLL） | **固定** |
| レジーム判定パラメータ（20/50等） | **固定** |
| exit条件 | **固定**（自信あり） |
| テンプレート選択（21種から） | **GA最適化** |
| テンプレートのパラメータ | **GA最適化** |

### GAの仕組み（ユーザーに説明済み）

```
グリッドサーチ: 1000パターン全部試す → 4時間
GA: 200〜400回で「ほぼ最適解」→ 30分〜1時間

理由: 悪いパターンは早々に淘汰。良い領域に集中探索。
```

### 時間見積もり

```
1銘柄 × 1レジーム: 200〜400回 → 30分〜1時間
1銘柄 × 3レジーム: 1.5〜3時間
3銘柄 × 3レジーム: 4.5〜9時間（直列）
→ 並列実行なら 1〜2時間
```

### 実装要件

1. **GA実装**: グリッドサーチの代替として `optimizer/genetic.py` を作成
2. **全パターン記録**: 淘汰されたものも含めてJSON保存
3. **進化過程の可視化**: 世代ごとの最高スコア推移

### 保存するデータ構造（案）

```json
{
  "symbol": "BTCUSDT",
  "regime": "range",
  "generations": [
    {
      "generation": 1,
      "individuals": [
        {
          "template": "macd_signal",
          "params": {"macd_fast": 10, "macd_slow": 25},
          "score": 0.12,
          "pnl": 12.5,
          "sharpe": 1.2,
          "status": "survived"
        },
        {
          "template": "rsi_reversal",
          "params": {"rsi_period": 14, "rsi_threshold": 30},
          "score": -0.05,
          "pnl": -5.2,
          "status": "eliminated",
          "reason": "bottom 75%"
        }
      ],
      "best_score": 0.12
    }
  ],
  "final_winner": {
    "template": "macd_signal",
    "params": {"macd_fast": 12, "macd_slow": 26},
    "score": 0.18
  }
}
```

---

### 運用方針

| 項目 | 状態 |
|------|------|
| テンプレート（コード） | **残す**（21種全部） |
| GA結果（淘汰履歴） | **JSON保存**（分析用） |
| 採用戦略リスト | **別管理**（実運用で使うやつ） |

運用フロー:
1. GA回す → 各レジームの最強が決まる
2. 採用戦略としてリストに追加
3. バッチ実行時は採用リストだけ使う
4. 将来見直したい時 → またGA回す → 結果が変われば差し替え

---

## 次回セッションでやること

1. `optimizer/genetic.py` を新規作成
2. 既存の `optimizer/grid.py` と統合（UIから選択可能に）
3. 結果保存の実装（全パターン + 採用リスト）
4. テスト実行して速度検証
